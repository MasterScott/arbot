#!/usr/bin/python

import pprint
import json
import argparse
from decimal import Decimal, ROUND_FLOOR
from ethchain import EthChain
from poloniex import Poloniex
from nicehash import Nicehash
from nanopool import Nanopool
from etherscan import Etherscan
from bittrex import Bittrex

pp = pprint.PrettyPrinter(indent=4)

dbFn = 'db.json'
authDbFn = 'auth.json'

parser = argparse.ArgumentParser(prog='myprogram')
parser.add_argument('--cache', action='store_true', default=False,
		    help='Use existing ' + dbFn + '.  Do not query remotes for data')
args = parser.parse_args()

authDb = None
db = {}

# TODO: doesn't work for some reason
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            return float(o)
        return super(DecimalEncoder, self).default(o)

def getDb(key):
	if key not in db:
		return None

	return db[key]

def putDb(key, value):
	db[key] = value

def queryData():
	chainEth = EthChain()
	stats = chainEth.basic_stats()
	putDb('chain.ETH.stats', stats)

	exchPolo = Poloniex()
	ticker = exchPolo.ticker()
	putDb('ticker', ticker)

	nh = Nicehash()
	balance = nh.balance(authDb)
	putDb('nh.balance', balance['result'])

	algoList = [ '20' ]
	for algo in algoList:
		for locationN in xrange(2):
			location = str(locationN)
			orders = nh.orders(location, algo)
			myOrders = nh.myOrders(authDb, location, algo)

			cacheKey = 'nh.markets.' + algo + '.' + location
			putDb(cacheKey, orders['result'])

			cacheKey = 'nh.markets.' + algo + '.' + location + '.my'
			putDb(cacheKey, myOrders['result'])

	poolNano = Nanopool()
	balance = poolNano.balance(authDb['nanopool']['address'])
	putDb('nanopool.balance', balance)

	es = Etherscan()
	balance = es.balance(authDb['nanopool']['address'],
			     authDb['etherscan']['apikey'])
	putDb('chain.ETH.balance', balance)

	eb = Bittrex()
	balances = eb.balances(authDb)
	putDb('bittrex.balances', balances)

def calcChainStats():
	ethstats = getDb('chain.ETH.stats')
	blocks = ethstats['data']['blocks']

	diffSum = Decimal(0)
	blockTimeSum = Decimal(0)

	for block in blocks:
		blockTimeSum = blockTimeSum + Decimal(block['blockTime'])
		diffSum = diffSum + Decimal(block['difficulty'])

	nBlocks = Decimal(len(blocks))
	blockTimeAvgDec = blockTimeSum / nBlocks
	blockTimeAvg = blockTimeAvgDec.to_integral_exact(rounding=ROUND_FLOOR)
	diffAvg = diffSum / nBlocks

	nethashGH = diffAvg / blockTimeAvg / Decimal('1e9')

	personalGH = Decimal(1)
	secstoGH = nethashGH / personalGH * blockTimeAvg
	daystoGH = secstoGH / Decimal(24 * 60 * 60)
	etherPerDay = Decimal(5) / daystoGH

	finalcalc = {
		'blocksAvgd': nBlocks,
		'blockTimeAvg': blockTimeAvg,
		'difficulty': diffAvg,
		'nethashGH': nethashGH,
		'daystoGH': daystoGH,
		'perDay': etherPerDay,
	}

	putDb('chain.ETH.calc', finalcalc)

def calcPrices():
	ticker = getDb('ticker')
	finalcalc = getDb('chain.ETH.calc')

	prices = {}
	prices['priceBTCETH'] = Decimal(ticker['BTC_ETH']['last'])
	prices['mktBTCGH'] = finalcalc['perDay'] * prices['priceBTCETH']

	startBTC = Decimal('1.0')
	prices['startBalance'] = startBTC
	prices['feeNH'] = (startBTC * Decimal(0.03)) + Decimal(0.0001)
	prices['feeExch'] = (startBTC * Decimal(0.0025))
	prices['feePool'] = (startBTC * Decimal(0.01))
	prices['feeChain'] = Decimal(0.0001) + Decimal(0.0001)
	prices['netBalance'] = (prices['startBalance'] - 
				prices['feeNH'] -
				prices['feeExch'] -
				prices['feePool'] -
				prices['feeChain'])

	prices['goalBTC'] = prices['startBalance']
	prices['goalETH'] = prices['goalBTC'] / prices['priceBTCETH']
	prices['goalGHD'] = prices['goalETH'] / finalcalc['perDay']
	prices['breakEven'] = prices['netBalance'] / prices['goalGHD']

	prices['pct1'] = prices['breakEven'] * Decimal('0.99')
	prices['pct2'] = prices['breakEven'] * Decimal('0.98')
	prices['pct3'] = prices['breakEven'] * Decimal('0.97')
	prices['pct4'] = prices['breakEven'] * Decimal('0.96')
	prices['pct5'] = prices['breakEven'] * Decimal('0.95')
	prices['pct10'] = prices['breakEven'] * Decimal('0.90')

	putDb('chain.BTCETH.prices', prices)

def readConfig():
	global authDb
	with open(authDbFn) as data_file:
		authDb = json.load(data_file)

def readDb():
	global db
	with open(dbFn) as data_file:
		db = json.load(data_file)

def writeDb():
	with open(dbFn, 'w') as outfile:
		json.dump(db, outfile, indent=2, sort_keys=True, cls=DecimalEncoder)

def main():
	readConfig()

	if args.cache:
		print("Reading cached data")
		readDb()
	else:
		print("Querying fresh data")
		queryData()

	calcChainStats()
	calcPrices()
	writeDb()

if __name__ == '__main__':
	main()

